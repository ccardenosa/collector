diff --git a/bpf/fillers.h b/bpf/fillers.h
index 2458b09..dfcc07c 100644
--- a/bpf/fillers.h
+++ b/bpf/fillers.h
@@ -1451,7 +1451,8 @@ static __always_inline pid_t bpf_task_tgid_vnr(struct task_struct *task)
 	return bpf_pid_vnr(bpf_task_tgid(task));
 }
 
-#elif LINUX_VERSION_CODE < KERNEL_VERSION(4, 19, 0)
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(4, 19, 0) && \
+    ( !defined(RHEL_RELEASE_CODE) || RHEL_RELEASE_CODE < RHEL_RELEASE_VERSION(8,1) )
 
 static __always_inline pid_t bpf_task_pid_nr_ns(struct task_struct *task,
 						enum pid_type type,
diff --git a/bpf/quirks.h b/bpf/quirks.h
index a26bfd9..410b0fe 100644
--- a/bpf/quirks.h
+++ b/bpf/quirks.h
@@ -40,6 +40,8 @@ or GPL2.txt for full copies of the license.
 #define BPF_SUPPORTS_RAW_TRACEPOINTS
 #endif
 
+#define RHEL_RELEASE_VERSION(X,Y) 0
+
 #endif /* RHEL_RELEASE_CODE */
 /* Redefine asm_volatile_goto to work around clang not supporting it
  */
diff --git a/ppm_cputime.c b/ppm_cputime.c
index 5e7c7e6..71563b0 100644
--- a/ppm_cputime.c
+++ b/ppm_cputime.c
@@ -231,7 +231,7 @@ static void cputime_advance(cputime_t *counter, cputime_t new)
  * runtime accounting.
  */
 static void cputime_adjust(struct task_cputime *curr,
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 3, 0))
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 3, 0)) || (PPM_RHEL_RELEASE_CODE > 0 && PPM_RHEL_RELEASE_CODE >= PPM_RHEL_RELEASE_VERSION(7, 6))
 			   struct prev_cputime *prev,
 #else
 			   struct cputime *prev,
diff --git a/ppm_events.c b/ppm_events.c
index 6c321f6..7e498e3 100644
--- a/ppm_events.c
+++ b/ppm_events.c
@@ -24,7 +24,7 @@ or GPL2.txt for full copies of the license.
 #include <linux/version.h>
 #include <linux/module.h>
 #include <linux/kernel.h>
-#include <asm/mman.h>
+#include <linux/mman.h>
 #include <linux/in.h>
 #if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 20)
 #include <linux/mount.h>
